/// Abstractions for Memory records
@ModuleInfo { minPklVersion = "0.28.2" }

@go.Package { name = "github.com/kdeps/schema/gen/memory" }

open module org.kdeps.pkl.Memory

extends "Utils.pkl"
import "package://pkg.pkl-lang.org/pkl-go/pkl.golang@0.10.0#/go.pkl"
import "package://pkl-lang.org/pkl-pantry/pkl.experimental.uri@1.0.3#/URI.pkl"
import "PklResource.pkl" as pklres
import "pkl:json"

/// Retrieves a memory record by its [id]
///
/// Returns the textual content of the memory entry, or an empty string if not found.
/// If the content is Base64-encoded, it will be automatically decoded.
///
/// [id]: The identifier of the memory record.
function getRecord(id: String?): String = 
    if (id != null) 
        let (content = read("memory:/\(id)")?.text ?? "")
        content
    else ""

/// Sets or updates a memory record with a new [value]
///
/// Returns the set value as confirmation.
///
/// [id]: The identifier of the memory record.
/// [value]: The value to store.
function setRecord(id: String?, value: String?): String = 
  if (id != null && value != null) 
    read("memory:/\(id)?op=set&value=\(URI.encodeComponent(value))")?.text ?? "" 
  else ""

/// Deletes a memory record by its [id]
///
/// Returns a confirmation message or an empty string if the record was not found.
///
/// [id]: The identifier of the memory record.
function deleteRecord(id: String?): String = if (id != null) read("memory:/\(id)?op=delete")?.text ?? "" else ""

/// Clears all memory records
///
/// Returns a confirmation message.
function clear(): String = read("memory:/_?op=clear")?.text ?? ""


/// Retrieves memory records with filtering using relational algebra
/// Uses cached select operations for better performance
///
/// [field]: The field to filter on
/// [operator]: The comparison operator ("eq", "ne", "gt", "lt", "gte", "lte", "contains", "in")
/// [value]: The value to compare against
/// [Mapping<String, String>]: The filtered memory records
function getFilteredRecords(field: String?, operator: String?, value: Dynamic): Mapping<String, String> =
    if (field != null && operator != null)
        let (condition = new pklres.SelectionCondition {
            field = field
            operator = operator
            value = value
        })
        let (selection = pklres.select("memory", new Listing<pklres.SelectionCondition> { condition }))
        if (selection != null && selection.rows != null)
            new Mapping<String, String> {
                for (row in selection.rows) {
                    when (row.data.containsKey("key") && row.data.containsKey("value")) {
                        [row.data["key"].toString()] = row.data["value"].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Retrieves memory records with multiple filters using relational algebra
/// Uses cached select operations for better performance
///
/// [conditions]: List of selection conditions
/// [Mapping<String, String>]: The filtered memory records
function getMultiFilteredRecords(conditions: Listing<Dynamic>): Mapping<String, String> =
    if (conditions != null)
        let (selectionConditions = conditions.map((condition) -> new pklres.SelectionCondition {
            field = condition["field"] as String
            operator = condition["operator"] as String
            value = condition["value"]
        }))
        let (selection = pklres.select("memory", selectionConditions))
        if (selection != null && selection.rows != null)
            new Mapping<String, String> {
                for (row in selection.rows) {
                    when (row.data.containsKey("key") && row.data.containsKey("value")) {
                        [row.data["key"].toString()] = row.data["value"].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Retrieves specific fields from memory records using relational algebra
/// Uses cached project operations for better performance
///
/// [fields]: List of fields to include
/// [Mapping<String, String>]: The projected memory records
function getRecordFields(fields: Listing<String>): Mapping<String, String> =
    if (fields != null)
        let (condition = new pklres.ProjectionCondition {
            columns = fields
        })
        let (projection = pklres.project("memory", condition))
        if (projection != null && projection.rows != null)
            new Mapping<String, String> {
                for (row in projection.rows) {
                    for (field in fields) {
                        when (row.data.containsKey(field)) {
                            [field] = row.data[field].toString()
                        }
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Retrieves memory records excluding specific fields using relational algebra
/// Uses cached project operations for better performance
///
/// [excludeFields]: List of fields to exclude
/// [Mapping<String, String>]: The projected memory records
function getRecordsExcludingFields(excludeFields: Listing<String>): Mapping<String, String> =
    if (excludeFields != null)
        let (condition = new pklres.ProjectionCondition {
            exclude = excludeFields
        })
        let (projection = pklres.project("memory", condition))
        if (projection != null && projection.rows != null)
            new Mapping<String, String> {
                for (row in projection.rows) {
                    for (field in row.data.keys) {
                        when (!excludeFields.contains(field)) {
                            [field] = row.data[field].toString()
                        }
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Joins memory records with another collection using relational algebra
/// Uses cached join operations for better performance
///
/// [otherCollection]: The other collection to join with
/// [memoryKey]: The key field in memory records
/// [otherKey]: The key field in the other collection
/// [joinType]: The type of join ("inner", "left", "right", "full")
/// [Mapping<String, String>]: The joined records
function joinWithCollection(otherCollection: String?, memoryKey: String?, otherKey: String?, joinType: String?): Mapping<String, String> =
    if (otherCollection != null && memoryKey != null && otherKey != null && joinType != null)
        let (condition = new pklres.JoinCondition {
            leftCollection = "memory"
            rightCollection = otherCollection
            leftKey = memoryKey
            rightKey = otherKey
            joinType = joinType
        })
        let (join = pklres.join(condition))
        if (join != null && join.rows != null)
            new Mapping<String, String> {
                for (row in join.rows) {
                    for (field in row.data.keys) {
                        [field] = row.data[field].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Searches memory records by content using relational algebra
/// Uses cached select operations with contains operator
///
/// [searchTerm]: The term to search for in memory content
/// [Mapping<String, String>]: The matching memory records
function searchRecords(searchTerm: String?): Mapping<String, String> =
    if (searchTerm != null)
        getFilteredRecords("value", "contains", searchTerm)
    else new Mapping<String, String> {}

/// Gets memory records by timestamp range using relational algebra
/// Uses cached select operations for time-based filtering
///
/// [startTime]: Start timestamp
/// [endTime]: End timestamp
/// [Mapping<String, String>]: The memory records in the time range
function getRecordsByTimeRange(startTime: Dynamic, endTime: Dynamic): Mapping<String, String> =
    if (startTime != null && endTime != null)
        let (selectionConditions = new Listing<pklres.SelectionCondition> {
            new pklres.SelectionCondition {
                field = "timestamp"
                operator = "gte"
                value = startTime
            }
            new pklres.SelectionCondition {
                field = "timestamp"
                operator = "lte"
                value = endTime
            }
        })
        let (selection = pklres.select("memory", selectionConditions))
        if (selection != null && selection.rows != null)
            new Mapping<String, String> {
                for (row in selection.rows) {
                    when (row.data.containsKey("key") && row.data.containsKey("value")) {
                        [row.data["key"].toString()] = row.data["value"].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}


/// Clears the query cache for memory operations
function clearCache(): String = pklres.clearCache()

/// Sets the cache TTL for memory query caching
/// [ttlSeconds]: Time to live in seconds
function setCacheTTL(ttlSeconds: Int): String = pklres.setCacheTTL(ttlSeconds)

/// Gets cache statistics for memory operations
function getCacheStats(): Dynamic = pklres.getCacheStats()

/// Performs a cached memory query with automatic caching
/// [queryType]: Type of query ("select", "project", "join")
/// [params]: Query parameters
function queryWithCache(queryType: String?, params: Dynamic): Dynamic = pklres.queryWithCache(queryType, params)
