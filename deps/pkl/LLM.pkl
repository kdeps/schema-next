/// Abstractions for Kdeps LLM operations
///
/// This module provides the structure for LLM (Large Language Model) operations within the Kdeps framework,
/// including chat interactions, response handling, and model configuration. It defines classes and functions
/// for managing LLM resources, processing prompts, and handling responses from various LLM models.
///
/// This module is part of the `kdeps` schema and provides a unified interface for LLM operations across
/// different models and providers.
///
/// The module defines:
/// - [ResourceChat]: For managing chat interactions with LLM models.
/// - [MultiChat]: For managing multi-turn chat conversations.
/// - [Tool]: For managing tool interactions with LLM models.
/// - Functions for retrieving and processing LLM responses.
@ModuleInfo { minPklVersion = "0.28.2" }

@go.Package { name = "github.com/kdeps/schema/gen/llm" }

open module org.kdeps.pkl.LLM

// Package imports
import "package://pkg.pkl-lang.org/pkl-go/pkl.golang@0.10.0#/go.pkl"
import "package://pkg.pkl-lang.org/pkl-pantry/pkl.experimental.uri@1.0.3#/URI.pkl"

// PKL standard library imports
import "pkl:json"
import "pkl:semver"
import "pkl:shell"
import "pkl:test"
import "pkl:xml"
import "pkl:yaml"

// Local module imports
import "Agent.pkl" as agent
import "Common.pkl" as common
import "Core.pkl" as core
import "Document.pkl" as document
import "Item.pkl" as item
import "Memory.pkl" as memory
import "PklResource.pkl" as pklres
import "Session.pkl" as session
import "Tool.pkl" as tool
import "Utils.pkl" as utils
import "Validation.pkl" as validation

// Use common utilities instead of local implementations
// - common.parseJsonOrNull for JSON parsing
// - common.safeRead for URI reading  
// - common.safeGetValue for pklres value retrieval


/// Class representing a chat interaction with an LLM model.
class ResourceChat {
    /// The name of the LLM model to use for the chat interaction.
    Model: String? = "llama3.2"

    /// The role or persona for the chat interaction.
    Role: String?

    /// The prompt or message to send to the LLM model.
    Prompt: String?

    /// The response received from the LLM model.
    Response: String?

    /// The file path where the response is stored.
    File: String?

    /// Whether the response should be in JSON format.
    JSONResponse: Boolean? = false

    /// A listing of specific keys to extract from the JSON response.
    JSONResponseKeys: Listing<String>?

    /// The timeout duration for the LLM request.
    TimeoutDuration: Duration? = 60.s

    /// The timestamp when the request was made.
    Timestamp: Duration?

    /// The scenario or context for the chat interaction.
    Scenario: Listing<MultiChat>?

    /// The tools available for the LLM to use.
    Tools: Listing<Tool>?

    /// The files associated with the chat interaction.
    Files: Listing<String>?

    /// A description of the chat interaction.
    Description: String?

    /// The listing of the item iteration results.
    ItemValues: Listing<String>?
}

/// Class representing a multi-turn chat conversation.
class MultiChat {
    /// The role or persona for this turn of the conversation.
    Role: String?

    /// The prompt text to be sent to the LLM model.
    Prompt: String?

    /// The content or message for this turn of the conversation.
    Content: String?

    /// A description of this turn of the conversation.
    Description: String?
}

/// Class representing a tool that can be used by an LLM model.
class Tool {
    /// The name of the tool.
    Name: String?

    /// The script content to execute for the tool.
    Script: String?
    
    /// The MCP server configuration for the tool.
    MCPServer: Uri?

    /// A description of what the tool does.
    Description: String?

    /// A mapping of parameter names to their properties for tool configuration.
    Parameters: Mapping<String, ToolProperties>?
}

/// Class representing a single parameter's properties in a tool definition.
class ToolProperties {
    /// Indicates if the parameter is required for the tool to function.
    Required: Boolean? = true

    /// The data type of the parameter (e.g., "string", "integer").
    Type: String?

    /// A description of the parameter's purpose.
    Description: String?
}

/// Retrieves the [ResourceChat] associated with the given [actionID].
///
/// If the resource is not found, returns a new [ResourceChat] with default values.
///
/// [actionID]: The actionID of the resource to retrieve.
/// [ResourceChat]: The [ResourceChat] object associated with the resource actionID.
function resource(actionID: String?): ResourceChat =
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (model = common.safeGetValue(resolvedID, "model"))
        let (role = common.safeGetValue(resolvedID, "role"))
        let (prompt = common.safeGetValue(resolvedID, "prompt"))
        let (response = common.safeGetValue(resolvedID, "response"))
        let (file = common.safeGetValue(resolvedID, "file"))
        let (jsonResponse = common.safeGetValue(resolvedID, "jsonResponse"))
        let (timeoutDuration = common.safeGetValue(resolvedID, "timeoutDuration"))
        
        new ResourceChat {
            Model = if (model != "") model else "llama3.2"
            Role = if (role != "") role else null
            Prompt = if (prompt != "") prompt else null
            Response = if (response != "") response else null
            File = if (file != "") file else null
            JSONResponse = if (jsonResponse != "") jsonResponse.toBoolean() else false
            TimeoutDuration = if (timeoutDuration != "") timeoutDuration.toDuration() else 60.s
        }
    else
        // Return default ResourceChat for null actionID
        new ResourceChat {}

/// Retrieves the response text associated with the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the response for.
/// [str]: The response text returned by the LLM model.
function response(actionID: String?): String? = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "response"))
        if (res != "") res else null
    else null

/// Retrieves the prompt text associated with the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the prompt for.
/// [str]: The prompt text sent to the LLM model.
function prompt(actionID: String?): String? = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "prompt"))
        if (res != "") res else null
    else null

/// Retrieves whether the LLM's response for the resource [actionID] is in JSON format.
///
/// [actionID]: The actionID of the resource to check for JSON response.
/// [bool]: True if the response is in JSON format, otherwise False.
function jsonResponse(actionID: String?): Boolean = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "jsonResponse"))
        if (res != "")
            res.toBoolean()
        else false
    else false

/// Retrieves the JSON response keys for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the JSON response keys for.
/// [Listing<String>]: A listing of the JSON response keys.
function jsonResponseKeys(actionID: String?): Listing<String> = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "jsonResponseKeys"))
        if (res != "")
            let (parsed = common.parseJsonOrNull(res))
            if (parsed != null) parsed as Listing<String> else new Listing<String> {}
        else new Listing<String> {}
    else new Listing<String> {}

/// Retrieves the item iteration responses for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the item values for.
/// [Listing<String>]: A listing of the item iteration responses.
function itemValues(actionID: String?): Listing<String> = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "itemValues"))
        if (res != "")
            let (parsed = common.parseJsonOrNull(res))
            if (parsed != null) parsed as Listing<String> else new Listing<String> {}
        else new Listing<String> {}
    else new Listing<String> {}

/// Retrieves the model name for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the model for.
/// [str]: The model name.
function model(actionID: String?): String = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "model"))
        if (res != "") res else "llama3.2"
    else "llama3.2"

/// Retrieves the role for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the role for.
/// [str]: The role.
function role(actionID: String?): String? = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "role"))
        if (res != "") res else null
    else null

/// Retrieves the file path for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the file for.
/// [str]: The file path.
function file(actionID: String?): String? = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "file"))
        if (res != "") res else null
    else null

/// Retrieves the timeout duration for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the timeout for.
/// [Duration]: The timeout duration.
function timeoutDuration(actionID: String?): Duration = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "timeoutDuration"))
        if (res != "") res.toDuration() else 60.s
    else 60.s

/// Retrieves the timestamp for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the timestamp for.
/// [Duration]: The timestamp.
function timestamp(actionID: String?): Duration = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "timestamp"))
        if (res != "") res.toDuration() else 0.s
    else 0.s

/// Retrieves the scenario for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the scenario for.
/// [Listing<MultiChat>]: The scenario.
function scenario(actionID: String?): Listing<MultiChat> = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "scenario"))
        if (res != "")
            let (parsed = common.parseJsonOrNull(res))
            if (parsed != null) parsed as Listing<MultiChat> else new Listing<MultiChat> {}
        else new Listing<MultiChat> {}
    else new Listing<MultiChat> {}

/// Retrieves the tools for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the tools for.
/// [Listing<Tool>]: The tools.
function tools(actionID: String?): Listing<Tool> = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "tools"))
        if (res != "")
            let (parsed = common.parseJsonOrNull(res))
            if (parsed != null) parsed as Listing<Tool> else new Listing<Tool> {}
        else new Listing<Tool> {}
    else new Listing<Tool> {}

/// Retrieves the files for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the files for.
/// [Listing<String>]: The files.
function files(actionID: String?): Listing<String> = 
    if (actionID != null)
        let (resolvedID = agent.resolveActionID(actionID))
        let (res = common.safeGetValue(resolvedID, "files"))
        if (res != "")
            let (parsed = common.parseJsonOrNull(res))
            if (parsed != null) parsed as Listing<String> else new Listing<String> {}
        else new Listing<String> {}
    else new Listing<String> {}

/// Retrieves LLM resources with filtering using relational algebra
/// Uses cached select operations for better performance
///
/// [field]: The field to filter on
/// [operator]: The comparison operator ("eq", "ne", "gt", "lt", "gte", "lte", "contains", "in")
/// [value]: The value to compare against
/// [Mapping<String, String>]: The filtered LLM resources
function getFilteredResources(field: String?, operator: String?, value: Dynamic): Mapping<String, String> =
    if (field != null && operator != null)
        let (condition = new pklres.SelectionCondition {
            field = field
            operator = operator
            value = value
        })
        let (selection = pklres.select("llm", new Listing<pklres.SelectionCondition> { condition }))
        if (selection != null && selection.rows != null)
            new Mapping<String, String> {
                for (row in selection.rows) {
                    when (row.data.containsKey("key") && row.data.containsKey("value")) {
                        [row.data["key"].toString()] = row.data["value"].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Retrieves LLM resources by model using relational algebra
/// Uses cached select operations for better performance
///
/// [modelName]: The model name to filter by
/// [Mapping<String, String>]: The LLM resources with the specified model
function getResourcesByModel(modelName: String?): Mapping<String, String> =
    if (modelName != null)
        getFilteredResources("model", "eq", modelName)
    else new Mapping<String, String> {}

/// Retrieves LLM resources by role using relational algebra
/// Uses cached select operations for better performance
///
/// [roleName]: The role to filter by
/// [Mapping<String, String>]: The LLM resources with the specified role
function getResourcesByRole(roleName: String?): Mapping<String, String> =
    if (roleName != null)
        getFilteredResources("role", "eq", roleName)
    else new Mapping<String, String> {}

/// Retrieves LLM resources by prompt content using relational algebra
/// Uses cached select operations with contains operator
///
/// [promptContent]: The prompt content to search for
/// [Mapping<String, String>]: The LLM resources matching the prompt content
function getResourcesByPromptContent(promptContent: String?): Mapping<String, String> =
    if (promptContent != null)
        getFilteredResources("prompt", "contains", promptContent)
    else new Mapping<String, String> {}

/// Retrieves LLM resources by response content using relational algebra
/// Uses cached select operations with contains operator
///
/// [responseContent]: The response content to search for
/// [Mapping<String, String>]: The LLM resources matching the response content
function getResourcesByResponseContent(responseContent: String?): Mapping<String, String> =
    if (responseContent != null)
        getFilteredResources("response", "contains", responseContent)
    else new Mapping<String, String> {}

/// Retrieves LLM resources by timestamp range using relational algebra
/// Uses cached select operations for time-based filtering
///
/// [startTime]: Start timestamp
/// [endTime]: End timestamp
/// [Mapping<String, String>]: The LLM resources in the time range
function getResourcesByTimeRange(startTime: Dynamic, endTime: Dynamic): Mapping<String, String> =
    if (startTime != null && endTime != null)
        let (selectionConditions = new Listing<pklres.SelectionCondition> {
            new pklres.SelectionCondition {
                field = "timestamp"
                operator = "gte"
                value = startTime
            }
            new pklres.SelectionCondition {
                field = "timestamp"
                operator = "lte"
                value = endTime
            }
        })
        let (selection = pklres.select("llm", selectionConditions))
        if (selection != null && selection.rows != null)
            new Mapping<String, String> {
                for (row in selection.rows) {
                    when (row.data.containsKey("key") && row.data.containsKey("value")) {
                        [row.data["key"].toString()] = row.data["value"].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Retrieves LLM resources by scenario using relational algebra
/// Uses cached select operations for scenario-based filtering
///
/// [scenarioName]: The scenario name to filter by
/// [Mapping<String, String>]: The LLM resources with the specified scenario
function getResourcesByScenario(scenarioName: String?): Mapping<String, String> =
    if (scenarioName != null)
        getFilteredResources("scenario", "contains", scenarioName)
    else new Mapping<String, String> {}

/// Retrieves specific fields from LLM resources using relational algebra
/// Uses cached project operations for better performance
///
/// [fields]: List of fields to include
/// [Mapping<String, String>]: The projected LLM resources
function getResourceFields(fields: Listing<String>): Mapping<String, String> =
    if (fields != null)
        let (condition = new pklres.ProjectionCondition {
            columns = fields
        })
        let (projection = pklres.project("llm", condition))
        if (projection != null && projection.rows != null)
            new Mapping<String, String> {
                for (row in projection.rows) {
                    for (field in fields) {
                        when (row.data.containsKey(field)) {
                            [field] = row.data[field].toString()
                        }
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Retrieves LLM resources excluding sensitive fields using relational algebra
/// Uses cached project operations for better performance
///
/// [excludeFields]: List of fields to exclude
/// [Mapping<String, String>]: The projected LLM resources
function getResourcesExcludingFields(excludeFields: Listing<String>): Mapping<String, String> =
    if (excludeFields != null)
        let (condition = new pklres.ProjectionCondition {
            exclude = excludeFields
        })
        let (projection = pklres.project("llm", condition))
        if (projection != null && projection.rows != null)
            new Mapping<String, String> {
                for (row in projection.rows) {
                    for (field in row.data.keys) {
                        when (!excludeFields.contains(field)) {
                            [field] = row.data[field].toString()
                        }
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Joins LLM resources with another collection using relational algebra
/// Uses cached join operations for better performance
///
/// [otherCollection]: The other collection to join with
/// [llmKey]: The key field in LLM resources
/// [otherKey]: The key field in the other collection
/// [joinType]: The type of join ("inner", "left", "right", "full")
/// [Mapping<String, String>]: The joined resources
function joinWithCollection(otherCollection: String?, llmKey: String?, otherKey: String?, joinType: String?): Mapping<String, String> =
    if (otherCollection != null && llmKey != null && otherKey != null && joinType != null)
        let (condition = new pklres.JoinCondition {
            leftCollection = "llm"
            rightCollection = otherCollection
            leftKey = llmKey
            rightKey = otherKey
            joinType = joinType
        })
        let (join = pklres.join(condition))
        if (join != null && join.rows != null)
            new Mapping<String, String> {
                for (row in join.rows) {
                    for (field in row.data.keys) {
                        [field] = row.data[field].toString()
                    }
                }
            }
        else new Mapping<String, String> {}
    else new Mapping<String, String> {}

/// Searches LLM responses by content using relational algebra
/// Uses cached select operations with contains operator
///
/// [searchTerm]: The term to search for in LLM responses
/// [Mapping<String, String>]: The matching LLM resources
function searchResponses(searchTerm: String?): Mapping<String, String> =
    if (searchTerm != null)
        getFilteredResources("response", "contains", searchTerm)
    else new Mapping<String, String> {}

/// Gets LLM resources with JSON responses using relational algebra
/// Uses cached select operations for JSON response filtering
///
/// [Mapping<String, String>]: The LLM resources with JSON responses
function getResourcesWithJsonResponses(): Mapping<String, String> =
    getFilteredResources("jsonResponse", "eq", true)


/// Clears the query cache for LLM operations
function clearCache(): String = pklres.clearCache()

/// Sets the cache TTL for LLM query caching
/// [ttlSeconds]: Time to live in seconds
function setCacheTTL(ttlSeconds: Int): String = pklres.setCacheTTL(ttlSeconds)

/// Gets cache statistics for LLM operations
function getCacheStats(): Dynamic = pklres.getCacheStats()

/// Performs a cached LLM query with automatic caching
/// [queryType]: Type of query ("select", "project", "join")
/// [params]: Query parameters
function queryWithCache(queryType: String?, params: Dynamic): Dynamic = pklres.queryWithCache(queryType, params)
